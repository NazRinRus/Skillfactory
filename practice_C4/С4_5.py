# Граф - список смежностей

G = {"Садовая": {"Сенная площадь": 4, "Спасская": 3, "Адмиралтейская": 4, "Звенигородская": 5},
     "Сенная площадь": {"Садовая": 4, "Спасская": 4},
     "Спасская": {"Сенная площадь": 4, "Садовая": 3, "Достоевская": 6},
     "Достоевская": {"Владимирская": 3, "Спасская": 6},
     "Владимирская": {"Достоевская": 3, "Пушкинская": 4},
     "Пушкинская": {"Владимирская": 4, "Звенигородская": 3},
     "Звенигородская": {"Пушкинская": 3, "Садовая": 5},
     "Адмиралтейская": {"Садовая": 4}}

# структура данных для хранения расстояний
D = {k : 100 for k in G.keys()} # словарь ключ - станция (вершина), значение - растояние до нее (по умолчанию 100)
start_k = 'Адмиралтейская'  # стартовая вершина
D[start_k] = 0  # расстояние от неё до самой себя равно нулю
# словарь с булевыми значениями, в котором True — если вершина (станция) просмотрена, иначе — False
U = {k : False for k in G.keys()}
P = {k : None for k in G.keys()} #для каждой вершины хранит вершину-предок с минимальным расстоянием
for _ in range(len(D)):
    # выбираем среди непросмотренных наименьшее по расстоянию
    min_k = min([k for k in U.keys() if not U[k]], key = lambda x: D[x])

    for v in G[min_k].keys():  # проходимся по всем смежным вершинам
         if D[v] > D[min_k] + G[min_k][v]:  # если расстояние от текущей вершины меньше
            D[v] = D[min_k] + G[min_k][v]  # то фиксируем его
            P[v] = min_k  # и записываем как предок
    U[min_k] = True  # просмотренную вершину помечаем

pointer = "Владимирская" # куда должны прийти
path = [] # список с вершинами пути

while pointer is not None: # перемещаемся, пока не придём в стартовую точку
   path.append(pointer)
   pointer = P[pointer]

path.reverse() # разворачиваем путь
for v in path:
    print(v)


print(D)